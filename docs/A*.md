## A*算法
A*算法是一种启发式搜索算法，用于在图或网格中寻找从起点到终点的最短路径。它结合了贪心策略与最佳优先搜索的特点，通过评估节点的**代价函数F(n) = G(n) + H(n)**来决定下一个要扩展的节点，其中：

    G(n)：从起始节点到当前节点的实际代价。
    H(n)：从当前节点到目标节点的估计代价（即启发式函数）。
以下是A*算法的步骤概述：

### 初始化：

定义起点节点 start 和目标节点 goal。
创建一个开放列表（如优先队列），用于存储待考察节点，初始时仅包含起点 start。
创建一个关闭列表，用于存储已考察过的节点，初始时为空。
为每个节点定义父节点指针，用于回溯构建路径。
初始化起点节点的 G 值为 0，其他节点的 G 值为无穷大。
计算起点节点的 H 值（通常基于某种距离度量，如曼哈顿距离、欧几里得距离或切比雪夫距离）。
### 循环搜索：

重复以下步骤，直到找到目标节点或者开放列表为空：
 a. 选择最优节点：从开放列表中取出具有最小 F 值的节点 current。 
 b. 检查是否到达目标：如果 current 等于目标节点 goal，则搜索结束，开始回溯构建路径。 
 c. 移出当前节点：将 current 从开放列表移至关闭列表。 
 d. 拓展邻居节点：对于 current 的每个未访问邻居节点 neighbor，执行以下操作： 
    i. 计算 G 值：如果通过 current 到达 neighbor 的代价小于已知的 neighbor G 值，则更新 neighbor 的 G 值，同时将其父节点指针指向 current。 
    ii. 计算 F 值：根据更新后的 G 值和 neighbor 的 H 值计算 F 值。 
    iii. 添加到开放列表：如果 neighbor 不在关闭列表中，将其加入到开放列表；如果已在开放列表中，根据新计算的 F 值调整其位置（保持开放列表按 F 值升序排列）。

### 路径回溯：

从目标节点 goal 开始，沿着父节点指针回溯至起点节点 start，依次记录这些节点，得到的就是从起点到目标的最短路径。

### 返回结果：

返回构建的最短路径或报告无解（若开放列表为空且未找到目标节点）。
注意：A* 算法的有效性和效率很大程度上取决于所选用的启发式函数 H(n)。
理想情况下，H(n) 应满足以下条件：

#### 条件 1：
一致性（Admissibility）：对任何节点 n，H(n) 必须不大于从 n 到目标节点实际的最短路径成本。这样可以保证 A* 找到的路径是最优的。
#### 条件 2：
优化性（Monotonicity）：对于任意节点 n 和其后继节点 m，有 H(n) ≤ H(m) + c(n, m)，其中 c(n, m) 是从 n 到 m 的实际代价。这有助于避免重复考察节点并加速搜索过程。
#### Ps:
实际应用中，设计一个好的启发式函数往往需要对问题域有深入理解。